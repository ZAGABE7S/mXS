class Node {
	public:
		static Node* m_root;
		static int m_nbItems;
		static int m_minimumFrequency;
		static double m_minimumConfidence;
		static double m_minimumConfidenceInter;
		static double m_smoothing;
		static double m_reductionFactor;
		static bool m_statistics;
		static bool m_minimals;
		static bool m_segmentals;
		static bool m_singleTarget;
		static bool m_limitedTarget;
		static bool m_onlyTarget;
		static bool m_debug;
		static bool m_siblings;
		static bool m_duplicates;
		static Transaction* m_transactions;
		static char** m_translation;
		static ItemTypeList** m_hierarchy;
		static bool* m_itemTypeIsTarget;
		static ITEMTYPE m_rootTarget;
		static Node* m_rootGroup;
		static int m_nbPatterns;
		static int m_nbMinimalOrMaximalPatterns;
		static int m_nbRules;
		static int m_nbConfidentRules;
		static int m_nbMinimalOrMaximalRules;
		static int m_nbConfidentMinimalOrMaximalRules;
		static int m_nbInformativeRules;
		static int m_nbConfidentInformativeRules;
		static int m_nbSelected;
		Node(ITEMTYPE, bool, bool, Node* = NULL);
		~Node();
		int generate(int);
		void count(int);
		int filter(int);
		int group(int);
		void output(int);
	private:
		ITEMTYPE m_itemType;
		bool m_isTarget;
		bool m_isTargetBegin;
		int m_nbTarget;
		int m_frequency;
		int m_frequencyTargetSequence;
		bool m_isMined;
		Node* m_alt;
		Node* m_next;
		ItemTypeList* m_maximalSibling;
		bool m_nextDuplicate;
		Node* m_minimalHierarchyLeft;
		bool /*Node**/ m_maximalHierarchy;
		bool /*Node**/ m_minimalLeft;
		bool /*Node**/ m_maximalLeft;
		bool /*Node**/ m_minimalRight;
		bool /*Node**/ m_maximalRight;
		bool /*Node**/ m_minimalManyfold;
		bool /*Node**/ m_maximalManyfold;
		bool /*Node**/ m_minimalTarget;
		bool /*Node**/ m_maximalTarget;
		int m_segmentLength;
		Node* findNodeForItemType(ITEMTYPE);
		Node* findNodeForPattern(int, ITEMTYPE*, int currentLength = 0);
		bool hasSameSegmentsAs(Node*);
		bool hasSimilarFrequencyAs(Node*, int = 1);
		static bool itemGeneralizesToItemType(Item*, ITEMTYPE);
		static bool itemTypeGeneralizesToItemType(ITEMTYPE, ITEMTYPE);
		int generate(int, int, ITEMTYPE*);
		void insertNextNode(ITEMTYPE, bool);
		void countItem(int, int, Item*, bool, Item* = NULL, ITEMTYPE = 0, bool = false, int = 0, Item* = NULL, int = 0);
		void countItemAlt(int, int, Item*, Item*, bool, Item*, ITEMTYPE, int, Item*, int);
		static bool isCountable(int, int, Item*, Item*, ITEMTYPE, Item*, ITEMTYPE, Item*, int);
		int filter(int, int, ITEMTYPE*, Node*);
		void prune(int, int, bool = false);
		int group(int, int, ITEMTYPE*, bool = true, bool = true);
		void groupHierarchy(int, int, ITEMTYPE*,  Node*, bool = true, bool = true, ITEMTYPE = 0, bool = false);
		void output(int, ITEMTYPE*, bool = true, bool = true);
		void outputLevel(int, int, ITEMTYPE*, bool = false);
		void outputNodePattern(int, ITEMTYPE*);
		static void outputPattern(int, ITEMTYPE*);
		static void outputItemType(ITEMTYPE);
};

